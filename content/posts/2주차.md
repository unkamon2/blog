---
title: 2주차
date: "2019-08-28T22:40:32.169Z"
template: "post"
draft: false
slug: "/posts/2주차"
category: "study"
tags:
- "web"
- "study"
- "Web Development"
description: "JavaScript"
socialImage: "/media/42-line-bible.jpg"
---
#2주차

##Document ; window의 객체로, window 생략하고 사용가능. 
document.createDocumentFragment() -> 자바스크립트로 document의 태그를 조작하는 것은 매우 성능이 떨어집니다. 특히 여러 태그를 반복문을 통해 동시에 추가할 때는요. 이럴 때 미리 가짜 document를 만들어서 여기에 추가를 한 후, 한 번에 document에 추가합니다. 이러면 진짜 document는 한 번만 조작하면 돼서 성능에 부담이 덜합니다.

##DOM ; Document Object Model. 
Node는 태그 노드와 텍스트 노드 전체를 가리키고, Element는 텍스트 노드를 제외하고, 흔히 생각하는 태그('<>'같은)만 가리킵니다. 따라서 태그만 검색하고 싶을 때는 Element가 붙은 메소드를 선택해야합니다.

##날짜와 정규표현식 ; 1월이 0, 일요일이 0

##객체지향; 
prototype은 모든 객체가 공유하고 있어서 한 번만 만들어지지만, this에 넣은 것은 객체 하나를 만들 때마다 메소드도 하나씩 만들어지기 때문에 불필요한 메모리 낭비가 발생합니다.

##scope; 함수의 범위. 스코프 체인 -> 가장 가까운 범위부터 찾아가는것
lexical scoping -> 스코프는 함수를 선언 할때 생기는 것으로, 선언시에 스코프 체인에 따른 참조를 말하는듯?
IIFE(즉시 호출 함수 표현식), 모듈 패턴 -> 'Iffy' 라고 발음합니다.(잎피...?)
사용 예 - (function () { console.log('Hello World') })(); // Hello World
리터럴의 조건은

예약어 function (필수)
함수이름 (선택)
매개변수 집합 (필수)
함수 본문 (필수)
인데, 2.함수이름이 '선택'조건이지만 함수 선언시에 이름이 없을 경우 에러가 납니다.
함수이름의 선택 조건은 2가지가 있는데,

함수를 할당 받을 변수를 지정
함수를 즉시 호출
와 같습니다.
예)

const add = function (a, b) { return a + b };
(function(a, b) { return a + b })(1, 2); // 3
이중에서 2번 예가 IIFE 의 예가 됩니다.
즉시 실행 함수의 방법으론 위의 2번처럼 함수를 ()로 묶어주거나,
+function(a, b) { return console.log(a + b) }(1, 2) 처럼 연산자를 앞에 붙여도 가능합니다.

##실행 컨텍스트; 실행 환경..? 
소스의 순서 : 코드 실행 -> 전역 컨텍스트 생성 -> 함수 호출 -> 함수 컨텍스트 생성 -> 변수객체, scope chain, this 생성 ->함수 실행 -> 함수 컨텍스트 사라짐 -> 페이지 종료 -> 전역 컨텍스트 사라짐 -> 클로저

호이스팅 -> 변수를 선언하고 초기화 했을 때, 선언 부분이 최상단으로 끌어올려지는 현상. 함수 표현식이 아니고 함수 선언식일 경우 호이스팅 현상 생김.

함수 표현식 : 일반적인 함수 선언이 아닌, javascript에서 사용하는 것으로,
var 함수명 = function () { 구현 로직 };와 같은 표현을 뜻함.
=> 함수 선언식 : 일반적인 함수 선언 방법. function 함수명(){}

클로저 -> 비공개 변수를 가질 수 있는 환경에 있는 함수

##콜백; 
함수 중 setTimeout({},초); 를 설정 해둬야 비동기적으로 실행됨.

##함수의 메소드와 아규먼트 ; 
유사배열...? : 배열과 같이 [] 형식으로 표시되지만, 객체로 구성되어 배열의 메소드를 사용할 수 없음. 배열의 프로토타입에서 call이나 apply 로 사용 가능

##객체 복사; 
hasOwnProperty??? : 객체가 특정 property(html DOM안에서 attribute를 가리키는 표현)를 가지고 있는지에 대한 여부를 반환. 본래의 것이 아닌 프로토타입으로 넣은 경우에는 false를 반환한다.

##패턴; 
모듈패턴, 싱글톤 패턴, 생성자 패턴 모듈패턴 : IIFE 싱글톤패턴 : 객체 리터럴이 대표적인 예

##함수형 프로그래밍; 
순수 함수..??? : 동일한 인자를 주면 항상 동일한 결과값을 리턴하고, 외부의 값을 변경하지 않는 함수.

##재귀와 메모이제이션;
분할 정복 알고리즘...? : 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 찾는 알고리즘.
알고리즘을 설계하는 요령 3가지<br/>
 1. Divide : 문제가 분할이 가능한 경우, 2개 이상의 문제로 나눈다.
 2. Conquer : 나누어진 문제가 여전히 분할이 가능하면, 또 다시 Divide를 수행한다. 그렇지 않으면 문제를 푼다.
 3. Combine : Conquer한 문제들을 통합하여 원래 문제의 답을 얻는다.
